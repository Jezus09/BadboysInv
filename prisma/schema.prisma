generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  avatar               String
  createdAt            DateTime              @default(now())
  id                   String                @id
  inventory            String?
  name                 String
  syncedAt             DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  coins                Decimal?              @default(0) @db.Decimal(10, 2)
  inventoryLastUpdateTime BigInt             @default(0)
  authTokens           ApiAuthToken[]
  currencyTransactions CurrencyTransaction[]
  caches               UserCache[]
  groups               UserGroup[]
  preferences          UserPreference?
  overwrites           UserRule[]
  caseOpenings         CaseOpening[]
  sentTrades           Trade[]               @relation("SentTrades")
  receivedTrades       Trade[]               @relation("ReceivedTrades")
  marketplaceListings  MarketplaceListing[]

  @@index([syncedAt])
  @@index([inventoryLastUpdateTime])
}

model UserCache {
  body      String
  timestamp DateTime
  url       String
  userId    String
  args      String?
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([url, userId])
  @@index([timestamp])
  @@index([userId])
}

model UserPreference {
  language         String?
  userId           String  @id
  background       String?
  statsForNerds    String?
  hideFreeItems    String?
  hideFilters      String?
  hideNewItemLabel String?
  user             User    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ApiCredential {
  apiKey     String         @id
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt
  scope      String?
  comment    String?
  authTokens ApiAuthToken[]
}

model ApiAuthToken {
  apiKey     String
  createdAt  DateTime      @default(now())
  token      String        @id @default(uuid())
  userId     String
  credential ApiCredential @relation(fields: [apiKey], references: [apiKey], onDelete: Cascade)
  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([apiKey])
}

model Rule {
  name            String      @id @unique
  type            String      @default("string")
  value           String
  groupOverwrites GroupRule[]
  userOverwrites  UserRule[]
}

model UserRule {
  name   String
  userId String
  value  String
  rule   Rule   @relation(fields: [name], references: [name], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([name, userId])
}

model Group {
  id         String      @id
  priority   Int         @default(0)
  overwrites GroupRule[]
  users      UserGroup[]
}

model UserGroup {
  groupId String
  userId  String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([groupId, userId])
}

model GroupRule {
  groupId String
  name    String
  value   String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  rule    Rule   @relation(fields: [name], references: [name], onDelete: Cascade)

  @@id([groupId, name])
}

model CurrencyTransaction {
  id            String   @id @default(uuid())
  userId        String
  amount        Decimal  @db.Decimal(10, 2)
  type          String
  reason        String?
  description   String?
  relatedUserId String?
  createdAt     DateTime @default(now())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}

model ShopItem {
  id            String   @id @default(uuid())
  name          String
  description   String?
  price         Decimal  @db.Decimal(10, 2)
  category      String   // "key", "case", "item"
  itemId        Int?     // CS2 economy item ID
  enabled       Boolean  @default(true)
  sortOrder     Int      @default(0)
  imageUrl      String?
  purchaseLimit Int?     // Max quantity user can purchase (null = unlimited)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([category])
  @@index([enabled])
}

model CaseOpening {
  id              String              @id @default(uuid())
  userId          String
  userName        String              // Cache user name for display
  userAvatar      String              // Cache user avatar for display
  caseItemId      Int                 // CS2 economy item ID of the case
  caseName        String              // Cache case name for display
  keyItemId       Int?                // CS2 economy item ID of the key used
  keyName         String?             // Cache key name for display
  unlockedItemId  Int                 // CS2 economy item ID of the unlocked item
  unlockedName    String              // Cache unlocked item name for display
  unlockedRarity  String?             // Cache unlocked item rarity for display
  createdAt       DateTime            @default(now())
  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages        CaseOpeningMessage[]

  @@index([createdAt])
  @@index([userId])
}

model CaseOpeningMessage {
  id            String       @id @default(uuid())
  caseOpeningId String
  userId        String
  userName      String       // Cache user name for display
  userAvatar    String       // Cache user avatar for display
  message       String
  replyToId     String?      // ID of message being replied to
  createdAt     DateTime     @default(now())

  caseOpening   CaseOpening  @relation(fields: [caseOpeningId], references: [id], onDelete: Cascade)
  replyTo       CaseOpeningMessage? @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies       CaseOpeningMessage[] @relation("MessageReplies")

  @@index([caseOpeningId])
  @@index([userId])
  @@index([createdAt])
}

model Trade {
  id                String      @id @default(uuid())
  senderUserId      String      // User who initiated the trade
  receiverUserId    String      // User who receives the trade
  senderItems       String      // JSON array of sender's items
  receiverItems     String      // JSON array of receiver's items
  senderCoins       Decimal     @default(0) // Coins offered by sender
  receiverCoins     Decimal     @default(0) // Coins offered by receiver
  status            TradeStatus @default(PENDING)
  message           String?     // Optional message from sender
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  expiresAt         DateTime    // Trade expiration time
  completedAt       DateTime?   // When trade was completed/cancelled
  
  // Relations
  senderUser        User        @relation("SentTrades", fields: [senderUserId], references: [id], onDelete: Cascade)
  receiverUser      User        @relation("ReceivedTrades", fields: [receiverUserId], references: [id], onDelete: Cascade)

  @@index([senderUserId])
  @@index([receiverUserId])
  @@index([status])
  @@index([createdAt])
}

enum TradeStatus {
  PENDING     // Waiting for receiver to respond
  ACCEPTED    // Receiver accepted, waiting for completion
  DECLINED    // Receiver declined
  COMPLETED   // Trade successfully completed
  CANCELLED   // Cancelled by sender
  EXPIRED     // Trade expired
}

model MarketplaceListing {
  id              String                @id @default(uuid())
  userId          String                // Seller's user ID
  itemUid         Int                   // Item UID from inventory
  itemData        String                // JSON serialized item data
  price           Decimal               @db.Decimal(10, 2) // Listing price
  status          MarketplaceStatus     @default(ACTIVE)
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  soldAt          DateTime?             // When item was sold
  buyerId         String?               // User who purchased the item
  expiresAt       DateTime              // Listing expiration time

  // Relations
  seller          User                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@index([price])
}

enum MarketplaceStatus {
  ACTIVE      // Listed and available for purchase
  SOLD        // Successfully sold
  CANCELLED   // Cancelled by seller
  EXPIRED     // Listing expired
}

model MarketplacePriceHistory {
  id          String   @id @default(uuid())
  itemId      Int      // CS2 economy item ID
  wear        Float?   // Item wear (for price comparison of same wear)
  price       Decimal  @db.Decimal(10, 2)
  listingId   String?  // Reference to marketplace listing (if still exists)
  soldAt      DateTime? // When it was sold (null = listing created)
  createdAt   DateTime @default(now())

  @@index([itemId, createdAt])
  @@index([itemId, wear, createdAt])
  @@index([createdAt])
}

model ItemHistory {
  id           String         @id @default(uuid())
  itemUuid     String         @unique // Global UUID for the item
  itemId       Int            // CS2 economy item ID
  wear         Float?         // Item wear value
  seed         Int?           // Item seed
  nameTag      String?        // Custom name tag
  stickers     String?        // JSON serialized stickers data
  createdAt    DateTime       @default(now())
  createdBy    String         // User ID who created/received the item
  source       String         // "DROP", "CASE", "SHOP", "TRADE", "MARKETPLACE", "CRAFT", "TRADEUP"
  currentOwner String?        // Current owner user ID (null if deleted/consumed)
  deletedAt    DateTime?      // When item was deleted/consumed

  // Relations
  transfers    ItemTransfer[]

  @@index([itemUuid])
  @@index([currentOwner])
  @@index([createdBy])
  @@index([createdAt])
}

model ItemTransfer {
  id           String      @id @default(uuid())
  itemUuid     String      // UUID of the item being transferred
  fromUser     String?     // Source user ID (null for new items)
  toUser       String      // Destination user ID
  transferType String      // "TRADE", "MARKETPLACE_SELL", "MARKETPLACE_BUY", "INITIAL_CREATE", "TRADEUP_CONSUME", "TRADEUP_REWARD"
  tradeId      String?     // Reference to Trade if applicable
  listingId    String?     // Reference to MarketplaceListing if applicable
  timestamp    DateTime    @default(now())
  metadata     String?     // Additional JSON metadata about the transfer

  // Relations
  itemHistory  ItemHistory @relation(fields: [itemUuid], references: [itemUuid], onDelete: Cascade)

  @@index([itemUuid])
  @@index([fromUser])
  @@index([toUser])
  @@index([timestamp])
  @@index([transferType])
}

// ============================================
// BadBoys CS2 Rank System Tables
// ============================================

model PlayerStats {
  steamId             String   @id @map("steam_id")
  playerName          String   @map("player_name")
  rankId              Int      @map("rank_id")
  experience          Int      @default(0)
  kills               Int      @default(0)
  deaths              Int      @default(0)
  assists             Int      @default(0)
  headshots           Int      @default(0)
  noscopeKills        Int      @default(0) @map("noscope_kills")
  wallbangKills       Int      @default(0) @map("wallbang_kills")
  smokeKills          Int      @default(0) @map("smoke_kills")
  blindKills          Int      @default(0) @map("blind_kills")
  roundsWon           Int      @default(0) @map("rounds_won")
  roundsLost          Int      @default(0) @map("rounds_lost")
  mvpCount            Int      @default(0) @map("mvp_count")
  bombPlants          Int      @default(0) @map("bomb_plants")
  bombDefuses         Int      @default(0) @map("bomb_defuses")
  totalDamage         Int      @default(0) @map("total_damage")
  shotsFired          Int      @default(0) @map("shots_fired")
  shotsHit            Int      @default(0) @map("shots_hit")
  playtimeSeconds     Int      @default(0) @map("playtime_seconds")
  kdRatio             Decimal  @default(0) @map("kd_ratio") @db.Decimal(10, 2)
  headshotPercentage  Decimal  @default(0) @map("headshot_percentage") @db.Decimal(10, 2)
  accuracyPercentage  Decimal  @default(0) @map("accuracy_percentage") @db.Decimal(10, 2)
  winPercentage       Decimal  @default(0) @map("win_percentage") @db.Decimal(10, 2)
  lastSeen            DateTime @default(now()) @map("last_seen")
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  rank                Rank     @relation(fields: [rankId], references: [id])

  @@map("player_stats")
  @@index([rankId])
  @@index([experience])
  @@index([kills])
}

model Rank {
  id            Int           @id @default(autoincrement())
  rankName      String        @unique @map("rank_name")
  rankTag       String        @map("rank_tag")
  rankImage     String?       @map("rank_image") // CS:GO rank icon filename (e.g., "1.svg", "18.svg")
  minExperience Int           @map("min_experience")
  maxExperience Int           @map("max_experience")
  rankColor     String        @map("rank_color")
  createdAt     DateTime      @default(now()) @map("created_at")

  players       PlayerStats[]

  @@map("ranks")
  @@index([minExperience])
}

model PlayerAdmin {
  steamId    String   @id @map("steam_id")
  adminRole  String   @map("admin_role")
  flags      String   @default("")
  isActive   Boolean  @default(true) @map("is_active")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  @@map("player_admins")
  @@index([isActive])
}

model PlayerBan {
  id        String    @id @default(uuid())
  steamId   String    @map("steam_id")
  bannedBy  String    @map("banned_by")
  reason    String
  bannedAt  DateTime  @default(now()) @map("banned_at")
  expiresAt DateTime? @map("expires_at")
  isActive  Boolean   @default(true) @map("is_active")

  @@map("player_bans")
  @@index([steamId])
  @@index([isActive])
  @@index([bannedAt])
}

model AdminLog {
  id              String   @id @default(uuid())
  adminSteamId    String   @map("admin_steam_id")
  actionType      String   @map("action_type")
  targetSteamId   String?  @map("target_steam_id")
  actionDetails   String?  @map("action_details")
  createdAt       DateTime @default(now()) @map("created_at")

  @@map("admin_logs")
  @@index([adminSteamId])
  @@index([actionType])
  @@index([createdAt])
}

model MarketplaceAnnouncement {
  id              String   @id @default(uuid())
  userId          String   // Seller's user ID
  userName        String   // Cache user name for display
  itemId          Int      // CS2 economy item ID
  itemName        String   // Cache item name for display
  itemRarity      String?  // Cache item rarity for color
  price           Decimal  @db.Decimal(10, 2) // Listing price
  announced       Boolean  @default(false) // Whether it was announced in-game
  createdAt       DateTime @default(now())

  @@index([announced])
  @@index([createdAt])
}

// ============================================
// 3D Sticker System
// ============================================

model Sticker {
  id              String            @id // e.g. "sticker-75"
  name            String            // e.g. "Sticker | Titan | Katowice 2014"
  description     String?           @db.Text
  rarityId        String?           // e.g. "rarity_rare"
  rarityName      String?           // e.g. "High Grade"
  rarityColor     String?           // e.g. "#4b69ff"
  type            String?           // "Team", "Event", etc.
  effect          String?           // "Foil", "Holo", "Gold", "Glitter", "Other"
  tournamentId    Int?
  tournamentName  String?
  imageUrl        String            // Steam CDN URL
  marketHashName  String?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  // Relations
  weaponStickers  WeaponSticker[]

  @@index([type])
  @@index([effect])
  @@index([tournamentId])
}

model UserWeaponInstance {
  id              String            @id @default(cuid())
  userId          String            // Owner's Steam ID
  weaponDefIndex  Int               // CS2 weapon def_index
  weaponName      String            // e.g. "AK-47 | Redline"
  weaponId        String            // e.g. "weapon_ak47"
  skinId          Int?              // Paint kit ID
  wear            Float?            // 0.0 - 1.0
  seed            Int?              // Pattern seed
  itemUuid        String?           @unique // Link to ItemHistory
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  // Relations
  stickers        WeaponSticker[]

  @@index([userId])
  @@index([weaponId])
  @@index([itemUuid])
}

model WeaponSticker {
  id              String              @id @default(cuid())
  weaponId        String              // UserWeaponInstance ID
  stickerId       String              // Sticker ID
  slot            Int                 // 1-5 (max 5 stickers per weapon)

  // 3D Position (world coordinates on weapon mesh)
  positionX       Float
  positionY       Float
  positionZ       Float

  // 3D Rotation (Euler angles)
  rotationX       Float               @default(0)
  rotationY       Float               @default(0)
  rotationZ       Float               @default(0)

  // Scale
  scale           Float               @default(1.0)

  // Optional: Wear/scrape level (0-1, 0=pristine, 1=removed)
  wear            Float               @default(0)

  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  // Relations
  weapon          UserWeaponInstance  @relation(fields: [weaponId], references: [id], onDelete: Cascade)
  sticker         Sticker             @relation(fields: [stickerId], references: [id])

  @@unique([weaponId, slot])
  @@index([weaponId])
  @@index([stickerId])
}
