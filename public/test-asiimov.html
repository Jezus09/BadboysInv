<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AK-47 Asiimov Test</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000814;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            z-index: 100;
        }
        #info h2 { margin: 0 0 10px 0; }
        #info button {
            margin: 5px;
            padding: 10px;
            cursor: pointer;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 3px;
        }
        #info button:hover { background: #0052a3; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="info">
        <h2>ðŸ”« AK-47 Asiimov Test</h2>
        <p>Status: <span id="status">Loading...</span></p>
        <button onclick="debugMode(0)">Normal Render (Lighting)</button>
        <button onclick="debugMode(1)">Show UV Colors</button>
        <button onclick="debugMode(2)">Show Alpha Channel</button>
        <button onclick="debugMode(3)">Show Pattern Only</button>
        <br>
        <button onclick="toggleRotation()">Toggle Rotation</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let weaponModel, shaderMaterial;
        let rotating = true;
        let currentDebugMode = 3; // Start with pattern only

        const status = document.getElementById('status');

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000814);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 2;
            controls.maxDistance = 20;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const dirLight1 = new THREE.DirectionalLight(0xffffff, 1);
            dirLight1.position.set(10, 10, 5);
            scene.add(dirLight1);

            const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight2.position.set(-10, -10, -5);
            scene.add(dirLight2);

            // Load textures and model
            loadAssets();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Animation loop
            animate();
        }

        function loadAssets() {
            status.textContent = 'Loading textures...';

            const textureLoader = new THREE.TextureLoader();
            const gltfLoader = new THREE.GLTFLoader();

            // Load textures
            const patternPromise = new Promise((resolve, reject) => {
                textureLoader.load(
                    '/textures/skins/asiimov_pattern.png',
                    (texture) => {
                        texture.minFilter = THREE.LinearFilter;
                        texture.magFilter = THREE.LinearFilter;
                        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                        resolve(texture);
                    },
                    undefined,
                    reject
                );
            });

            const modelPromise = new Promise((resolve, reject) => {
                gltfLoader.load(
                    '/models/ak47/weapon_rif_ak47.gltf',
                    resolve,
                    undefined,
                    reject
                );
            });

            Promise.all([patternPromise, modelPromise])
                .then(([patternTexture, gltf]) => {
                    status.textContent = 'Assets loaded! Applying shader...';
                    setupModel(gltf, patternTexture);
                })
                .catch((error) => {
                    status.textContent = 'ERROR: ' + error.message;
                    console.error('Loading error:', error);
                });
        }

        function setupModel(gltf, patternTexture) {
            weaponModel = gltf.scene;

            // Center and scale the model
            const box = new THREE.Box3().setFromObject(weaponModel);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            weaponModel.position.sub(center);

            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 0.3 / maxDim;
            weaponModel.scale.setScalar(scale);

            console.log('Model dimensions:', size);
            console.log('Scale factor:', scale);

            // Apply shader to body meshes AND magazine (clip)
            weaponModel.traverse((child) => {
                if (child.isMesh && (child.name.includes('body_legacy') || child.name.includes('body_hd') || child.name.includes('clip'))) {
                    console.log('Applying shader to:', child.name);

                    shaderMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            patternTexture: { value: patternTexture },
                            brightness: { value: 1.0 },
                            debugMode: { value: currentDebugMode }
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            varying vec3 vNormal;

                            void main() {
                                vUv = uv;
                                vNormal = normalize(normalMatrix * normal);
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform sampler2D patternTexture;
                            uniform float brightness;
                            uniform int debugMode;

                            varying vec2 vUv;
                            varying vec3 vNormal;

                            void main() {
                                // UV transformation - flip V coordinate
                                vec2 uv = vUv;
                                uv.y = 1.0 - uv.y;

                                // Sample pattern texture
                                vec4 patternColor = texture2D(patternTexture, uv);

                                // Debug modes
                                if (debugMode == 1) {
                                    // Show UV as colors
                                    gl_FragColor = vec4(uv.x, uv.y, 0.0, 1.0);
                                } else if (debugMode == 2) {
                                    // Show alpha channel
                                    gl_FragColor = vec4(vec3(patternColor.a), 1.0);
                                } else if (debugMode == 3) {
                                    // Show pattern only (no lighting)
                                    gl_FragColor = vec4(patternColor.rgb, 1.0);
                                } else {
                                    // Normal render with lighting
                                    vec3 finalColor = patternColor.rgb * brightness;
                                    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.5));
                                    float diff = max(dot(vNormal, lightDir), 0.5);
                                    finalColor *= diff;
                                    gl_FragColor = vec4(finalColor, 1.0);
                                }
                            }
                        `
                    });

                    child.material = shaderMaterial;
                }
            });

            scene.add(weaponModel);
            status.textContent = 'Loaded! Showing: Pattern Only (Debug Mode 3)';
        }

        function debugMode(mode) {
            if (!shaderMaterial) return;
            currentDebugMode = mode;
            shaderMaterial.uniforms.debugMode.value = mode;

            const modes = ['Normal Render (Lighting)', 'UV Colors', 'Alpha Channel', 'Pattern Only'];
            status.textContent = 'Debug Mode: ' + modes[mode];
        }

        function toggleRotation() {
            rotating = !rotating;
            status.textContent = (rotating ? 'Rotation ON' : 'Rotation OFF') + ' | Mode: ' + currentDebugMode;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (weaponModel && rotating) {
                weaponModel.rotation.y += 0.005;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
